### Test-And-Set锁

这是最简单的锁，现实生活中的场景是这样的：

假设有一家租赁锁的店，但店里只有一把锁可以出租，不妨设有十个人想要租这把锁，`TAS/CAS`相当于这十个人每次都要前往店里查看这把锁在不在。没租到锁九个人都各自回家，离谱的是，他们刚回到家又要折返回店里抢夺锁的使用权。

但是有一个很现实的问题是，每次都有九个人浪费时间前往店里，却空手而归，这样不仅很累，而且通常十个人都要走一条小路，这样就会同时导致路被堵死。

### Test-Test-And-Set锁

还是相同的场景，现在十个人只需要在最开始的时候去店里看一次有没有锁可以出租，没有的话就回家。如果锁被归还了，店老板就会打电话给十个人通知他们前来租锁，显然，第一个到的人可以租到锁。

但是这样还是有三个问题：

1. 老板每次都要打好多次电话`(Cache-Coherent Traffic)`
2. 十个人同时去往店里的时候，还是会导致小路堵塞。而且等待的时间比较长，时间没有用到刀刃上`(Critical Section Underutilization)`
3. 不公平，应该以第一次到店里的顺序排队；而且有可能有人一直拿不到锁用`(Starvation)`

### Array-Based Queue锁

还是假设有十个人要租锁，现在老板在店里放十个相邻的小箱子，然后把锁放在第一个小箱子里。

**租锁**：每次有人来的时候，老板都会告诉他现在可以占哪一个箱子`(tail)`，然后下一个人来就占下一个箱子。现在每个人都自己占了一个箱子，同时还会往箱子里放下自己的电话号码，然后就可以回家了。

**还锁**：用完锁的人回来归还的时候，直接把锁放入他所占有的箱子的相邻位置的下一个箱子，这个时候，老板就会拨打放着锁的箱子里的电话号码，通知相应的人来取锁。

这个实现方法解决了小路堵塞的问题以及公平性的问题，同时等待的时间比较短，开销`(overhead)`可以接受。

但是，这个方法需要太多箱子了，如果有好几个店都要满足相同的抢夺场景，那就意味着每个店都要放很多个箱子。另外，店里只能准备有限个箱子，需要提前确定最多有多少个人来排队，但是一般很难事先确定最大客流量。

另外，还有一个隐患：

`False Sharing`: 如果有某些箱子里的电话号码是相同的座机号码`(Same Cache Line)`，那么店家打电话过去的时候就可能同时通知不止一个人，于是有人又要白跑一趟。这个问题可以这样解决：老板发现客人留下的是座机号码时，就提醒客人要留下移动电话号码`(Padding)`。



#### Hint: 既然店家负责准备箱子的要求不太现实，那么可以让客人自己带一个箱子，用完之后带走一个箱子(不一定是自己的箱子)

### CLH Queue锁

店家准备一个箱子，把锁放进这个箱子里。

**租锁**：当有人到店里租锁时，老板会告诉他现在队伍的末尾是哪个箱子。然后客人就把这个队伍末尾的箱子`(tail)`作为他的前一个记住`(myPred)`，再把自己的电话号码放入前一个箱子里。接着把自己的箱子放下`(myNode)`。

**还锁**：当有人回来还锁的时候，会直接把锁放进自己的那个箱子里，然后拿走他之前记住的前一个箱子`(myPred)`，接着离开。老板同时发现锁回来了，就会拨打放着锁的那个箱子里放的电话，通知人来拿。

这个方法很好地解决了需要太多箱子的问题，但是有一个隐患：如果每位客人的箱子质量不同，或者外形不同，而客人不愿意拿别人的箱子用怎么办？`(Different NUMAs)`

### MCS Queue锁

**租锁**：当有人来租锁的时候，老板会告诉他队伍的末尾是哪个箱子`(tail)`，若当前没人用锁，则告诉他现在没有人`(nullptr)`。分两种情况：

1. 若当时没有用锁，那么老板直接把锁给这个人
2. 否则，这个人把自己的电话号码放在自己的箱子里，并且把自己箱子的位置写下来放入前一个箱子里。

**还锁**：有人回来还锁的时候，也有两种情况：

1. 如果自己的箱子里放着一个箱子的位置，那么就找到这个箱子把锁放下
2. 先观察自己的箱子，若箱子里没有位置，说明后面暂时没人来。接着准备离开，就去找老板通知他现在已经没人了`(CAS)`，却发现自己现在不是队伍的最后`(tail)`，那么就说明有人来了。那么这个时候就再等一段时间，后面来的人就会过来放下自己的位置，拿到位置之后，就把锁放入对应的箱子。

最后，拿着自己的箱子离开。

同样，老板也会同时发现锁回来了，就会找到放着锁的箱子，然后拨打箱子里放着的电话号码，拨打电话通知客人来租锁。



显然，这个方法解决了客人希望带走自己的箱子而不是别人的箱子的问题`(NUMA Locality)`。

