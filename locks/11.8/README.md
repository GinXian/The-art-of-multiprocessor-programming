### Test-And-Set锁

假设现在有一家专门出租锁的店，并且有十个人想要租锁。

**租锁**：租锁的人来到店里之后，如果是最先到店里的人，就可以拿走锁；否则，只能空手而归，但是比较不合理的是，没有租到锁的人一回到家就要马上折返回到店里继续租锁。

**还锁**：还锁的人来到店里后，直接把锁还给老板。

这个方法的确可以实现`Mutual Exclusion`的效果，但是存在几个问题：

1. 每次都同时有多个人前往租锁，假设他们都要走同一条小路，如此便会导致道路堵塞。`(Bus Congestion)`
2. 每个没有租到锁的人都要来回折返，十分费力，而且租到锁的几率也不大。`(Cache Miss)`
3. 不公平，不符合`First-Come-First-Served`的分配规则，因此会导致有的人一直租不到锁`(Starvation)`

### Test-Test-And-Set锁

现在的租锁规则如下：

**租锁**：租锁的人来到店里之后，如果是最先到店的人，就可以拿走锁；否则，则留下自己的电话号码，然后离开。

**还锁**：还锁的人回到店里把锁还给老板，然后离开。老板拿到锁之后，立即打电话给所有人到店里租锁。

这个方法成功解决了第一个问题，避免了客人来回折返的问题。但是，也带来了一个新的问题：老板每次需要打很多个电话，打电话的成本也很高`(Cache Coherence Traffic)`。

这个现实生活的例子中，每位没有租到锁的客人第一次到店里之后，看到没有锁可以租用的事实然后离开，脑子里记住了这个信息，就相当于`Cache`。而老板每次打电话通知，就是在更新缓存`(Cache Update)`。

### Array-Based Queue锁

继续改进租锁策略，现在老板会在店里准备十个箱子，然后把锁放入第一个箱子：

**租锁**：租锁的人来到店里之后，老板会告诉他现在可以占用哪一个箱子(注：箱子是依次顺序分配的)`(tail)`，这个人就记住自己的箱子`(mySlotIndex)`。然后，这个人找到自己的箱子，如果箱子里放着锁，就直接拿走；否则，在箱子里放入一张写着自己电话号码的纸条，然后离开。

**还锁**：还锁的人回到店里之后，直接把锁放入与自己的箱子相邻的下一个箱子中，然后把自己箱子里写着电话号码的纸条带走，即可离开。老板发现锁已经被归还后，就会找到放着锁的箱子，如果箱子里有电话号码，就拨打这个号码通知客人前来租锁。

这个方法解决了公平性、道路阻塞的问题，以及老板每次需要拨打多个电话的问题`(Cache Coherence Traffic)`。但是，仍然存在几个问题：

1. 需要准备太多箱子，假设现在有若干个店出租锁，那么每个店都需要准备十个箱子。但是，每个客人同时只能到一个店里，那么就意味着有很多箱子是冗余的。`(High Space Complexity)`
2. 队列的容量是有限的，而且老板需要事先确认最大客流量，这在现实中是不太可能获得的信息。`(Poor Scalability)`
3. 有一种特殊情况：假设某些人占用箱子之后，会在相邻的多个箱子里放下写着自己电话号码的纸条。而当老板需要拨打电话的时候，在箱子里发现了多个号码，但是无法确定哪一个才是真正的客人，因此只能全部都拨打一遍。这个时候又会出现老板每次需要拨打多个电话的情况`(Cache Coherence Traffic)`。而除了真正的客人之外的其他客人，都是白跑一趟，因为他们的箱子里根本没有锁`(Cache Miss)`。这种特殊情况称为`False Sharing`。

`False Sharing`的原理：我们日常所说的内存其实包含缓存`(Cache)`和主存`(Main Memory)`。而从主存中`Load`到缓存中的单位是`Cache Line`，大小通常为64字节。现在假设有两个处理器核心，以及两个`L1 Cache`。当一个核心修改内存时，会导致主存中同属一个`Cache Line`区域的空间发生修改，并且同时将另一个核心的`L1 Cache`无效化，这个时候就会迫使另一个核心重新从主存中读入相应的`Cache Line`。也就意味着，这两个核心每次发生写入操作时，都会导致另一个的缓存失效，这样就会导致严重的性能损耗`(Performance Overhead)`。

要解决`False Sharing`也不困难，只需要保证变量所占空间不在同一个`Cache Line`上。在现实的租锁故事里，老板只需要监督禁止客人往多个箱子里放入电话号码即可。

#### 既然由店家准备箱子是不合理的，那么就让客人自带箱子，用完之后带走一个箱子(不一定是自己带去的那一个箱子)。

### CLH Queue锁

现在店里只会准备一个箱子，然后把锁放入箱子：

**租锁**：租锁的人来到店里之后，老板会告诉他现在队列的末尾是哪一个箱子`(tail)`，并且记下自己的前一个客人的箱子的位置`(myPred)`。然后这个人将自己的箱子放下，同时老板会记住这个箱子的位置`(Update Tail)`，这个人也会记住自己的箱子的位置`(myNode)`。接着，如果前一个箱子里放着锁，那么就直接带走；否则，就在这个箱子里放下写着自己电话号码的纸条。

**还锁**：还锁的人来到店里之后，直接把锁放在自己的箱子里，然后取走自己记住的前一个箱子`(Update myNode)`，即可离开。老板发现锁已经归还之后，马上找到放着锁的那个箱子，如果箱子里有电话号码的话，就拨打电话通知客人来租锁。

这个方法很好地复用了箱子，但是还有一个隐患，就是：如果客人的箱子形状、质量各异，而客人也都不希望拿走别人的箱子，都只希望带走自己的箱子怎么办？`(NUMA Inlocality)`

### MCS Queue锁

现在店里不准备箱子：

**租锁**：租锁的人来到店里，有两种情况：

1. 如果前面没有人，就把自己的箱子放下，然后直接拿走锁
2. 否则，老板会告诉客人现在队列的末尾`(tail)`，客人先把自己的箱子放下，把自己的电话号码放入自己的箱子里，并且记住自己的箱子的位置。然后找到这个末尾的箱子，把自己的箱子的位置写在纸条上，并且放入这个末尾的箱子里。

**还锁**：还锁的人回到店里，有两种情况：

1. 若自己的箱子里有纸条，就直接找到纸条上写着的箱子，把锁放入该箱子中
2. 若自己的箱子里没有纸条，就说明自己已经是队伍的最后一个，队伍已经要清空了。这个时候准备把锁还给老板，这是也有两种情况：
   - 若老板说又来了新的客人，则等一下新来的客人前来放纸条，拿到纸条之后，就找到那个箱子，把锁放入箱子。
   - 若老板说没有新的客人了，则直接把锁还给老板

最后带着自己的箱子离开。

这个方法保证了每个客人各自带走自己的箱子。